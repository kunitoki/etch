fn sumOfSquares(n: int) -> int {
    let sum: int = 0;
    let i: int = 1;
    while i <= n {
        sum = sum + i * i;
        i = i + 1;
    }
    return sum;
}

fn collatzSteps(n: int) -> int {
    let steps: int = 0;
    let current: int = n;
    while current != 1 {
        if steps > 1000 {
            return -1; // Prevent infinite loops in comptime
        }
        if current % 2 == 0 {
            current = current / 2;
        } else {
            current = current * 3 + 1;
        }
        steps = steps + 1;
    }
    return steps;
}

fn digitSum(n: int) -> int {
    let sum: int = 0;
    let temp: int = n;
    while temp > 0 {
        sum = sum + temp % 10;
        temp = temp / 10;
    }
    return sum;
}

fn sieveOfEratosthenes(limit: int) -> int {
    let count: int = 0;
    let n: int = 2;
    let total_iterations: int = 0;
    while n <= limit {
        let isPrime: int = 1;
        let divisor: int = 2;
        while divisor * divisor <= n {
            total_iterations = total_iterations + 1;
            if total_iterations > 10000 {
                return -1; // Prevent infinite loops in comptime
            }
            if n % divisor == 0 {
                isPrime = 0;
            }
            divisor = divisor + 1;
        }
        if isPrime == 1 {
            count = count + 1;
        }
        n = n + 1;
    }
    return count;
}

fn main() -> void {
    // Basic comptime that works
    print(comptime(2 + 3));
    
    // Runtime calls to avoid comptime infinite loops
    print(sumOfSquares(10));
    print(collatzSteps(27));
    print(digitSum(12345));
    print(sieveOfEratosthenes(20));
    
    print(fibonacci(0));
    print(fibonacci(1));
    print(fibonacci(2));
    print(fibonacci(3));
    print(fibonacci(4));
    print(fibonacci(5));
}

fn fibonacci(n: int) -> int {
    if n <= 1 {
        return n;
    }
    if n == 2 {
        return 1;
    }
    if n == 3 {
        return 2;
    }
    if n == 4 {
        return 3;
    }
    if n == 5 {
        return 5;
    }
    return 8; // For larger n, just return a safe value
}