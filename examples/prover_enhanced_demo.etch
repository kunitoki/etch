// ============================================================================
// Enhanced Prover Constraint System Demonstration
// ============================================================================
// This file demonstrates the new recursive constraint application system
// that can handle complex, nested conditions.

// ----------------------------------------------------------------------------
// Feature 1: Reversed Comparisons
// ----------------------------------------------------------------------------
// The prover can now handle comparisons where the variable is on the RHS
// Example: "5 > x" is understood as "x < 5"

fn demoReversedComparison() -> void {
  let arr: array[int] = [10, 20, 30, 40, 50];
  let index = 2;

  // Old limitation: Only "x < 5" would work
  // New capability: "5 > x" also works!
  if 5 > index and index >= 0 {
    // Prover knows: index in [0, 4]
    // Since arr has 5 elements [0..4], this is safe
    print("Reversed: " + string(arr[index]));  // ✅ Proven safe!
  }
}

// ----------------------------------------------------------------------------
// Feature 2: Expression-Based Constraints
// ----------------------------------------------------------------------------
// The prover can now evaluate expressions on the RHS of comparisons
// Example: "index < #arr" dynamically uses the array length

fn demoExpressionConstraint(arr: array[int], idx: int) -> string {
  // The RHS "#arr" is evaluated to get the array size
  // This works even though #arr is not a constant!
  if idx >= 0 and idx < #arr {
    // Prover knows: idx in [0, arraySize-1]
    return "Value: " + string(arr[idx]);  // ✅ Proven safe!
  }
  return "Out of bounds";
}

// ----------------------------------------------------------------------------
// Feature 3: Deeply Nested AND Conditions
// ----------------------------------------------------------------------------
// The prover recursively applies constraints from nested AND expressions
// Example: "a > 0 and b < 10 and c >= 5" applies all three constraints

fn demoNestedAnd(x: int, y: int, z: int) -> void {
  // Triple nested AND condition
  if x >= 0 and x < 10 and y >= x and y < 20 and z >= 0 {
    // Prover tracks:
    // - x in [0, 9]
    // - y in [x, 19] (where x in [0, 9], so y in [0, 19])
    // - z in [0, max]
    print("All conditions satisfied");
  }
}

// ----------------------------------------------------------------------------
// Feature 4: Complex Nested Structure
// ----------------------------------------------------------------------------
// Conditions can be arbitrarily nested with multiple levels of AND/OR

fn demoComplexNesting(arr: array[int], i: int, j: int) -> void {
  // Complex nested condition with multiple variables
  if i >= 0 and i < #arr {
    if j >= i and j < #arr {
      // Both i and j are proven to be in bounds!
      let sum = arr[i] + arr[j];  // ✅ Both accesses proven safe!
      print("Sum: " + string(sum));
    }
  }
}

// ----------------------------------------------------------------------------
// Feature 5: Multiple Variables in Single Condition
// ----------------------------------------------------------------------------
// The prover collects all variables mentioned in a condition and refines each

fn demoMultipleVariables(x: int, y: int) -> void {
  let arr: array[int] = [1, 2, 3, 4, 5];

  // Both x and y are constrained by this condition
  if x >= 0 and y >= 0 and x < #arr and y < #arr {
    // Prover knows: x in [0, 4], y in [0, 4]
    print("Both safe: " + string(arr[x]) + ", " + string(arr[y]));
  }
}

// ----------------------------------------------------------------------------
// Feature 6: Constraint Propagation Through Branches
// ----------------------------------------------------------------------------
// Each branch gets its own independent environment with constraints applied

fn demoConstraintPropagation(value: int) -> string {
  if value >= 0 and value < 10 {
    // In then-branch: value in [0, 9]
    return "Small: " + string(value);
  } else {
    // In else-branch: value < 0 OR value >= 10
    // (Conservative - we can't narrow further for OR)
    return "Large or negative";
  }
}

// ----------------------------------------------------------------------------
// Main: Run All Demonstrations
// ----------------------------------------------------------------------------

fn main() -> void {
  print("=== Enhanced Prover Constraint System Demo ===");
  print("");

  print("1. Reversed Comparisons:");
  demoReversedComparison();
  print("");

  print("2. Expression-Based Constraints:");
  let numbers: array[int] = [100, 200, 300];
  print(demoExpressionConstraint(numbers, 1));
  print("");

  print("3. Deeply Nested AND:");
  demoNestedAnd(5, 15, 10);
  print("");

  print("4. Complex Nesting:");
  let data: array[int] = [10, 20, 30, 40];
  demoComplexNesting(data, 1, 3);
  print("");

  print("5. Multiple Variables:");
  demoMultipleVariables(2, 4);
  print("");

  print("6. Constraint Propagation:");
  print(demoConstraintPropagation(7));
  print("");

  print("✅ All demonstrations completed successfully!");
}
