<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Etch - Define once, Etch forever</title>

		<link rel="stylesheet" href="dist/reset.css">
		<link rel="stylesheet" href="dist/reveal.css">
		<link rel="stylesheet" href="dist/theme/black.css">

		<!-- Theme used for syntax highlighted code -->
		<link rel="stylesheet" href="plugin/highlight/monokai.css">

		<style>
			/* Global reset and base styles */
			.reveal h1, .reveal h2, .reveal h3 {
				text-transform: none;
				font-weight: 600;
			}

			/* Default heading sizes - balanced proportions */
			.reveal h1 {
				font-size: 2.2em;
				margin-bottom: 0.5em;
				line-height: 1.1;
			}
			.reveal h2 {
				font-size: 1.5em;
				margin-bottom: 0.4em;
				line-height: 1.2;
			}
			.reveal h3 {
				font-size: 1.15em;
				margin-bottom: 0.35em;
				line-height: 1.2;
			}

			/* Body text and lists - proportional to headings */
			.reveal p, .reveal li {
				font-size: 0.85em;
				line-height: 1.5;
				margin-bottom: 0.5em;
			}
			.reveal ul, .reveal ol {
				margin-top: 0.5em;
				margin-bottom: 0.5em;
			}
			.reveal li {
				margin-bottom: 0.35em;
			}

			/* Strong text */
			.reveal strong {
				font-weight: 700;
				color: #64FFDA;
			}

			/* Images */
			.reveal section img {
				border: none;
				box-shadow: none;
				background: none;
			}

			/* Color accents */
			.reveal .checkmark {
				color: #00FF00;
			}
			.reveal .xmark {
				color: #FF6B6B;
			}
			.reveal .accent {
				color: #64FFDA;
			}

			/* Code blocks - proportional sizing */
			.reveal pre {
				margin: 0.6em 0;
				font-size: 0.7em;
				width: 100%;
			}
			.reveal pre code {
				max-height: 480px;
				font-size: 0.7em;
				line-height: 1.35;
				padding: 0.8em;
			}

			/* Tables - balanced sizing */
			.reveal table {
				font-size: 0.6em;
				line-height: 1.2;
				margin: 0.5em auto;
			}
			.reveal table th,
			.reveal table td {
				padding: 0.3em 0.5em;
			}

			/* Blockquotes */
			.reveal blockquote {
				font-size: 0.85em;
				padding: 0.6em 1em;
				margin: 0.6em 0;
			}

			/* Slide alignment */
			.slides section {
				text-align: left;
			}
			.slides section.center {
				text-align: center;
			}

			/* Compact slide styling for content-heavy slides - tighter spacing */
			.reveal .compact h1 {
				font-size: 1.4em;
				margin-bottom: 0.25em;
				line-height: 1.0;
			}
			.reveal .compact h2 {
				font-size: 1.1em;
				margin-bottom: 0.2em;
				line-height: 1.0;
			}
			.reveal .compact h3 {
				font-size: 0.9em;
				margin-bottom: 0.15em;
				line-height: 0.8;
			}
			.reveal .compact p {
				font-size: 0.6em;
				line-height: 1.2;
				margin-bottom: 0.25em;
			}
			.reveal .compact li {
				font-size: 0.58em;
				line-height: 1.25;
				margin-bottom: 0.15em;
			}
			.reveal .compact ul,
			.reveal .compact ol {
				margin-top: 0.25em;
				margin-bottom: 0.25em;
			}
			.reveal .compact pre {
				margin: 0.4em 0;
				font-size: 0.68em;
			}
			.reveal .compact pre code {
				max-height: 420px;
				font-size: 0.68em;
				line-height: 1.25;
				padding: 0.6em;
			}
			.reveal .compact table {
				font-size: 0.68em;
				line-height: 1.25;
			}
		</style>

		<style>
			/* Custom syntax highlighting colors for Etch language */
			.reveal .hljs table {
 			    margin: auto !important;
			}
			.reveal pre code .hljs-keyword {
				color: #F92672 !important; /* Pink - keywords like if, else, while, for, return */
			}
			.reveal pre code .hljs-type {
				color: #66D9EF !important; /* Cyan - types like int, float, void, bool */
			}
			.reveal pre code .hljs-built_in {
				color: #A6E22E !important; /* Green - built-in functions like print, rand, readFile */
			}
			.reveal pre code .hljs-title {
				color: #FD971F !important; /* Orange - function names in definitions */
			}
			.reveal pre code .hljs-string {
				color: #E6DB74 !important; /* Yellow - string literals */
			}
			.reveal pre code .hljs-number {
				color: #AE81FF !important; /* Purple - numeric literals */
			}
			.reveal pre code .hljs-literal {
				color: #AE81FF !important; /* Purple - true, false */
			}
			.reveal pre code .hljs-function > .hljs-title:last-child {
				color: #66D9EF !important; /* Orange - function names */
			}
			.reveal pre code .hljs-comment {
				color: #75715E !important; /* Gray - comments */
			}
		</style>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<!-- Slide: Title Slide -->
				<section class="center compact" data-markdown>
					<textarea data-template>
						# **ETCH**
						## Define **Once**, Etch **Forever**.

						<img src="assets/slide0.jpg" alt="Etch Matches" style="max-width: 40%; border-radius: 10px; margin: 20px auto;">

						A language that *keeps you safe* before it even runs,<br>
						yet feels like *you're just scripting* - **until it blows your mind!**
					</textarea>
				</section>

				<!-- Slide: Why Etch? -->
				<section class="center compact" data-markdown>
					<textarea data-template>
						## Why Etch? ğŸ¤”

						**The Origin Story Nobody Asked For (But You're Getting Anyway)**

						The Endless Quest: ğŸ”

						- Spent *years* hunting for the "perfect" scripting engine.
						- Lua? *Too bare.* Python? *Too slow.* JavaScript? *Too... JavaScript.*
						- Tried them all. They all lacked *something*.
						- Performance âš¡ vs Safety ğŸ›¡ï¸ vs Simplicity ğŸ“. You can only **pick two**.

						---

						## Why Etch? ğŸ¤”

						**The Origin Story Nobody Asked For (But You're Getting Anyway)**

						The "Why Not?" Moment: ğŸ’¡

						- **Plot twist:** Compilers are actually **FUN** to build! ğŸ‰
						- Living in the age of AI: *"Make an app!"* ğŸ¤–
						- Me: *"...What if I make a LANGUAGE instead?"* ğŸ¯
						- **YOLO Compiler Theory!**

						---

						## Why Etch? ğŸ¤”

						**The Origin Story Nobody Asked For (But You're Getting Anyway)**

						The Mad Experiment: ğŸš€

						- Built Etch as a *playground* for compiler tech
						- Prove correctness? *Why not!*
						- Safety without complexity? *Challenge accepted!*
						- **Etch: Because life's too short** ğŸ”¥

					</textarea>
				</section>

				<!-- Slide: The Problem -->
				<section class="center compact" data-markdown>
					<textarea data-template>
						## The Bugs That Haunt Your Dreams

						Those sneaky runtime gremlins - the ones that compile just fine, only to explode right when you hit play.

						**Numerical Safety Issues:**
						- âŒ Division by zero crashes
						- âŒ Integer overflow vulnerabilities

						**Memory Safety Issues:**
						- âŒ Nullptr dereferencing
						- âŒ Uninitialized variable bugs

						**Array and Bounds Issues:**
						- âŒ Array bounds errors
						- âŒ Buffer overflows
						- âŒ Platform-dependent behavior

						---

						## Compile-Time Safety Verification

						Etch proves safety properties at compile-time through static analysis.

						**Safety Guarantees:**
						- âœ… No division by zero
						- âœ… No integer overflow
						- âœ… No nullptr dereferences
						- âœ… No uninitialized variables
						- âœ… No array out of bounds errors

						**Additional Benefits:**
						- âœ… Dead code automatically eliminated
						- âœ… Redundant checks removed
						- âœ… Errors caught before deployment
					</textarea>
				</section>

				<!-- Slide: Language Architecture Overview -->
				<section class="center compact" data-markdown>
					<textarea data-template>
						## ğŸ‘‹ nuqneH, Etch!

						```etch [1-3]
						fn main() -> void {
						    print("Hello, World!");
						}
						```

						**C-like syntax** you already know-*simple, clean, familiar*.

						No need to learn *Klingon* to say hello! ğŸ––

						---

						## ğŸ—ï¸ Language Architecture

						**Multi-stage compilation pipeline:**

						```txt

											ğŸ“„ Source Code
												â†“
											ğŸ” Frontend (Lexer â†’ Parser â†’ AST)
												â†“
											ğŸ¨ Type Checker (Inference + Validation)
												â†“
											ğŸ›¡ï¸ Safety Prover (Range Analysis + Symbolic Execution)
												â†“
											âš¡ Comptime Executor (AST Transformation)
														   â†“
												â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
												â†“                     â†“
											ğŸ’¾ Bytecode VM      ğŸ”§ C Code Generator


						```

						âœ… **Each stage adds safety guarantees**

						---

						## ğŸ“‹ The Compilation Pipeline

						**Staged transformation with safety guarantees at each step:**

						| Stage | Process | Output |
						|-------|---------|--------|
						| 1ï¸âƒ£ | **Lexer** | Token stream (frontend/lexer) |
						| 2ï¸âƒ£ | **Parser** | AST (frontend/ast - frontend/parser) |
						| 3ï¸âƒ£ | **Type Checker** | Typed + Inferred AST (typechecker/) |
						| 4ï¸âƒ£ | **Safety Prover** | Proven AST (prover/) |
						| 5ï¸âƒ£ | **Comptime Executor** | Transformed AST (comptime/) |
						| 6ï¸âƒ£ | **Bytecode Generator** | Register VM bytecode (interpreter/) |
						| 7ï¸âƒ£ | **Cache** | Disk (`__etch__/` directory) |
						| 8ï¸âƒ£ | **VM / C Backend** | Execution or native binary (backend/) |
					</textarea>
				</section>

				<!-- Slide: Frontend Design -->
				<section class="center compact" data-markdown>
					<textarea data-template>
						## ğŸ” Frontend: Lexer â†’ Parser

						**Token-based lexical analysis:**
						- ğŸ“ Position tracking for error reporting
						- âš¡ Efficient single-pass scanning
						- ğŸ¯ Source location preservation

						**Recursive descent parser:**
						- ğŸŒ³ Produces strongly-typed AST
						- ğŸ“ Expression kinds: Binary ops, Calls, Arrays, Pattern matching
						- ğŸ”€ Statement kinds: Declarations, Control flow, Assignments
						- ğŸ›¡ï¸ Syntax validation during parsing

						Note: frontend/lexer.nim and frontend/parser.nim

						---

						## ğŸŒ³ AST Node Types

						**Expression variants (20+ types):**
						- ğŸ”¢ **Literals**: `ekInt`, `ekFloat`, `ekString`, `ekBool`, `ekChar`
						- â• **Operations**: `ekBin`, `ekUn`, `ekCall`
						- ğŸ“¦ **Collections**: `ekArray`, `ekIndex`, `ekSlice`, `ekArrayLen`
						- ğŸ­ **Pattern matching**: `ekMatch`, `ekOptionSome`, `ekResultOk`
						- ğŸ—ï¸ **Objects**: `ekObjectLiteral`, `ekFieldAccess`, `ekNew`

						**Statement variants (15+ types):**
						- ğŸ“Œ **Declarations**: `skLet`, `skVar`, `skFun`, `skType`
						- ğŸ”€ **Control flow**: `skIf`, `skWhile`, `skFor`, `skReturn`
						- âš™ï¸ **Others**: `skAssign`, `skDefer`, `skComptime`

						---

						## ğŸ¨ Type Kinds

						**Primitive Types:**
						- âœ… `tkBool` (1 byte)
						- ğŸ“ `tkChar` (1 byte)
						- ğŸ”¢ `tkInt` (8 bytes, signed)
						- ğŸ”¢ `tkFloat` (8 bytes, double)
						- ğŸ“ `tkString`
						- ğŸš« `tkVoid`

						**Composite Types:**
						- ğŸ“¦ `tkArray` - Fixed and dynamic arrays
						- ğŸ”— `tkRef` - References with generational tracking
						- ğŸ—ï¸ `tkObject` - Structured data with fields

						---

						## ğŸ¨ Type Kinds

						**Advanced Types:**
						- â“ `tkOption` - Optional values (some/none)
						- âœ¨ `tkResult` - Result types (ok/error)
						- ğŸ­ `tkGeneric` - Generic type parameters
						- ğŸ”— `tkUnion` - Sum types

						---

						## ğŸ¯ Type System: Three-Phase Process

						**Phase 1: Type Collection** ğŸ“š

						- Gather all type definitions and global variables
						- Build forward reference table
						- Create type environment

						---

						## ğŸ¯ Type System: Three-Phase Process

						**Phase 2: Type Inference** ğŸ”®

						- Hindley-Milner style inference for generics
						- Constraint generation and unification
						- Return type inference from body
						- Generic function instantiation on demand

						---

						## ğŸ¯ Type System: Three-Phase Process

						**Phase 3: Type Validation** âœ…

						- Expression type checking (expressions.nim)
						- Statement type checking (statements.nim)
						- Full program validation
					</textarea>
				</section>

				<!-- Slide: Prover Architecture -->
				<section class="center compact" data-markdown>
					<textarea data-template>
						## ğŸ›¡ï¸ Prover: Safety Through Analysis

						**Safety analysis through symbolic execution**

						**Core Components:**
						- ğŸ” **expression_analysis**: Range propagation, expression evaluation
						- â• **binary_operations**: Arithmetic operation range inference
						- ğŸ”€ **symbolic_execution**: Control flow analysis
						- âš¡ **function_evaluation**: Pure function compile-time execution

						**Key Concept is tracking values**<br>
						- known/unknown
						- min/max range
						- non-zero/non-null
						- initialized/used/last use
						- is array/string
						- array/string size

						*Every variable has a proven state at every program point!*

						---

						## ğŸ”¬ Prover: Analysis Phases

						**Phase 1: Environment Setup** ğŸ“‹
						- Initialize environment with variable declarations
						- Add all globals to environment

						---

						## ğŸ”¬ Prover: Analysis Phases

						**Phase 2: Global Analysis** ğŸŒ
						- Analyze global variable initializations
						- Track global value ranges

						---

						## ğŸ”¬ Prover: Analysis Phases

						**Phase 3: Function Analysis** ğŸ¯
						- Prove main function first
						- Analyze all reachable functions
						- Validate safety at every operation

						---

						## ğŸ”¬ Prover: Analysis Phases

						**Phase 4: Property Validation** âœ…
						- Check non-zero divisors (division/modulo)
						- Verify array bounds safety
						- Prevent integer overflow
						- Ensure variable initialization

						---

						## The Safety Prover in Action

						```etch [3|4|5]
						// âœ… Safe!
						fn main() -> void {
						    let divisor: int = rand(5, 10);         // Range: [5, 10]
						    let calculation: int = 100 / divisor;   // âœ… Safe!
						    print(calculation);
						}
						```

						**Safe Example:** divisor ranges [5, 10] â†’ division succeeds âœ…

						---

						## The Safety Prover in Action

						```etch [3|4|9-14]
						// âŒ COMPILE ERROR
						fn main() -> void {
						    let divisor: int = rand(5);             // Range: [0, 5]
						    let calculation: int = 100 / divisor;   // âŒ COMPILE ERROR
							print(calculation);
						}

						/*
						Compiling: xyz.etch
						xyz.etch:4:32: error: cannot prove divisor is non-zero in main
						3 |     let divisor: int = rand(5);             // Range: [0, 5]
						4 |     let calculation: int = 100 / divisor;   // âŒ COMPILE ERROR
														   ^
						5 |     print(calculation);
						*/
						```

						**Unsafe Example:** divisor ranges [0, 5] â†’ *COMPILE ERROR* âŒ

						Compiler tracks value ranges and proves divisor should be non-zero.
					</textarea>
				</section>

				<!-- Slide: Arrays with Safety Guarantees -->
				<section class="center compact" data-markdown>
					<textarea data-template>
						## ğŸ“¦ Arrays with Safety Guarantees

						```etch [1-7]
						fn main() -> void {
						    let numbers: array[int] = [10, 20, 30, 40, 50];

						    let count: int = #numbers;              // Length operator
						    let middle: int = numbers[count / 2];   // Bounds checked
						    let slice = numbers[1:4];               // Safe slicing, inferred as array[int]
						}
						```

						- âœ… Compile-time bounds checking when possible
						- ğŸ” Compiler enforces insertion of runtime checks when necessary
						- ğŸ“ Clear error messages
					</textarea>
				</section>

				<!-- Slide: Type System & Inference -->
				<section class="center compact" data-markdown>
					<textarea data-template>
						## ğŸ¨ Type System & Inference

						```etch [1-6]
						fn main() -> void {
						    let x: int = 42;           // Explicit type
						    let y = 3.14;              // Inferred as float
						    let name = "Etch";         // Inferred as string
						    let numbers = [1, 2, 3];   // Inferred as array[int]
						}
						```

						- âœ¨ **Strong static typing**
						- ğŸ”® **Smart type inference**
						- âœ… **No surprises**

						---

						## ğŸ—ï¸ Types and Objects

						**Type Aliases, Unions and Object Definitions:**

						```etch [2|3|6|8-12|15-16]
						// Type aliases for clarity
						type UserId = int;
						type Email = distinct string;

						// Union types for sum types
						type IntOrString = int | string;

						// Object types with fields
						type Point = object {
						  x: int;
						  y: int;
						};

						fn main() -> void {
						  let p: Point = { x: 10, y: 20 };
						  print(p.x + p.y);  // 30
						}
						```

						**Safety Guarantees:**
						- ğŸ›¡ï¸ All object fields must be initialized before use
						- âœ… Prover tracks initialization of each field
						- ğŸ” Compile-time error if accessing uninitialized field
					</textarea>
				</section>

				<!-- Slide: UFCS -->
				<section class="center compact" data-markdown>
					<textarea data-template>
						## ğŸ¯ Uniform Function Call Syntax

						**Call functions as methods using dot notation:**

						```etch [1-3|6-7|9-10|12-14|16-17]
						fn add(a: int, b: int) {
						  return a + b;
						}

						fn main() {
						  var x: int = 10;
						  var y: int = 20;

						  // Traditional call
						  discard add(x, y);

						  // UFCS - first argument becomes receiver
						  var result2: int = x.add(y);
						  print(result2); // 30

						  // But also!
						  print(5.add(15)); // 20
						}
						```

						**Clean, readable method-style calls without OOP overhead!** ğŸš€
					</textarea>
				</section>

				<!-- Slide: Pattern Matching - Basics -->
				<section class="center compact" data-markdown>
					<textarea data-template>
						## ğŸ¨ Pattern Matching: Option & Result

						**Safe value extraction with exhaustive matching:**

						```etch [1-7|10|11-18|19]
						fn divideInts(a: int, b: int) -> result[int] {
						  if b == 0 {
						    return error("Division by zero");
						  } else {
						    return ok(a / b);
						  }
						}

						fn main() -> void {
						  let divResult: result[int] = divideInts(42, 6);
						  let message: string = match divResult {
						    ok(value) => {
						      "Success: " + toString(value);
						    }
						    error(err) => {
						      "Failed: " + err;
						    }
						  };
						  print(message);  // "Success: 7"
						}
						```

						---

						## ğŸ¨ Pattern Matching: Advanced

						**Option types and nested patterns:**

						```etch [1-7|10|11|13-16|17]
						fn tryGetElement(arr: array[int], index: int) -> option[int] {
						  if index >= 0 and index < #arr {
						    return some(arr[index]);
						  } else {
						    return none;
						  }
						}

						fn main() -> void {
						  let numbers: array[int] = [10, 20, 30];
						  let maybeValue: option[int] = tryGetElement(numbers, 1);

						  let result: string = match maybeValue {
						    some(value) => "Found: " + toString(value);
						    none => "Not found";
						  };
						  print(result);  // "Found: 20"
						}
						```

						**Compiler enforces exhaustive pattern coverage!** âœ…
					</textarea>
				</section>

				<!-- Slide: Defer -->
				<section class="center compact" data-markdown>
					<textarea data-template>
						## â° Defer: Guaranteed Cleanup

						**Execute cleanup code when scope exits:**

						```etch [2|6|10|8|4]
						fn main() {
						  print("Start");

						  defer { print("Cleanup - runs last!"); }

						  print("Middle");

						  defer { print("Second cleanup"); }

						  print("End");
						}
						```

						**Output:**
						```txt
						Start
						Middle
						End
						Second cleanup
						Cleanup - runs last!
						```

						**Defers execute in reverse order (LIFO)** - Perfect for resource cleanup! ğŸ§¹
					</textarea>
				</section>

				<!-- Slide: Import System -->
				<section class="center compact" data-markdown>
					<textarea data-template>
						## ğŸ“¦ Import System: Modules & CFFI

						**Module Imports (Etch code):**
						```etch [1-2]
						import math
						import math { sqrt, pow }
						```

						**C FFI Imports (Native libraries):**
						```etch [1-5|8-10]
						import ffi cmath {
						  fn sin(x: float) -> float;
						  fn cos(x: float) -> float;
						  fn sqrt(x: float) -> float;
						}

						fn main() -> void {
						  var pi: float = 3.14159;
						  var sine: float = sin(pi / 2.0);
						  print(sine);  // ~1.0
						}
						```

						**Zero-cost abstractions:**
						- ğŸš€ Direct C function calls (no overhead)
						- ğŸ”— Dynamic library loading (runtime)
						- âœ… Type-safe FFI boundaries
					</textarea>
				</section>

				<!-- Slide: Compile-Time Execution -->
				<section class="center compact" data-markdown>
					<textarea data-template>
						## âš¡ Compile-Time Execution

						**Comptime evaluation during compilation:**

						Not macros or templates-actual code execution in the compiler.

						**Comptime Use Cases**

						- ğŸ¯ **Build-time configuration**: Different builds from same source
						- ğŸ“Š **Lookup tables**: Compute once at compile-time, use at runtime
						- ğŸš© **Feature flags**: Conditional compilation based on environment
						- ğŸ“¦ **Resource embedding**: Templates, shaders, assets in binary
						- ğŸ·ï¸ **Version information**: Embed git commit hash, build date
						- ğŸŒ **Platform-specific code**: Single codebase for multiple targets

						---

						## Comptime Basics

						```etch [6-7|9-11]
						fn square(x: int) -> int {
						    return x * x;
						}

						fn main() -> void {
							// Prints 64 during compilation
						    comptime{ print(square(8)); }

							// Evaluates to constant at compile-time
							let sq: int = comptime(square(8));
							print(sq);
						}
						```

						**Zero runtime overhead**
						- Function calls happen during compilation
						- Results embedded as constants in bytecode
						- No function call overhead at runtime

						---

						## Comptime Blocks

						```etch [1-14]
						fn main() -> void {
						    comptime {
						        print("Hello from the compiler!");

						        var i: int = 0;
						        while i < 5 {
						            i = i + 1;
						        }

								print(i);
						    }

						    print("Hello from runtime!");
						}
						```

						**Compile-time output:**
						```txt
						Hello from the compiler!
						5
						```

						**Runtime output:**
						```txt
						Hello from runtime!
						```

						---

						## File Embedding

						```etch [2-4]
						fn main() -> void {
						    // File read at COMPILE-TIME
						    let config: string = comptime(readFile("config.txt"));
						    print(config);  // File embedded in binary!
						}
						```

						**Embed files directly into your binary**
						- No runtime I/O
						- No missing file errors
						- Single executable deployment

						---

						## Code Injection

						```etch [2|3|5-11|14-16]
						fn main() -> void {
						    comptime {
						        let env: string = readFile(".env");

						        if env == "production" {
						            inject("LOG_LEVEL", "int", 0);
						            inject("DEBUG", "bool", false);
						        } else {
						            inject("LOG_LEVEL", "int", 2);
						            inject("DEBUG", "bool", true);
						        }
						    }

						    if DEBUG { // Variable was injected!
						        print("Debug mode enabled");
						    }
						}
						```

						**Metaprogramming without macros**, generate code based on compile-time conditions
					</textarea>
				</section>

				<!-- Slide: Register-Based VM Architecture -->
				<section class="center compact" data-markdown>
					<textarea data-template>
						## ğŸ”€ Two Execution Modes

						**Single source, dual execution paths:**

						```txt
													Etch Compiler
														â†“
													Bytecode â”€â”€â”€â”€â”€â”€â†’ C Backend
														â†“                â†“
													Bytecode VM      C Compiler
														â†“                â†“
													Execution        Execution
						```

						ğŸ”§ **Bytecode VM:** Fast iteration, debugger support, portable caching

						ğŸš€ **C Backend:** Native performance, compiler optimizations, standalone binary

						**Development workflow:** ğŸ§ª VM for rapid â†’ ğŸ“¦ C for deployment

						---

						## ğŸ”§ Bytecode VM - Fast Development

						**Perfect for development iteration:**

						- âš¡ Instant execution (cached)
						- ğŸ› Full debugger support
						- ğŸ“¦ Portable bytecode
						- ğŸš« No C compiler needed
						- ğŸ”— FFI to C libraries (runtime)
						- ğŸ“ Rich runtime errors

						---

						## ğŸš€ C Backend - Maximum Performance

						**Compiles to clean, readable C code:**

						- ğŸ¯ Native machine code via gcc/clang
						- âš¡ Platform optimizations (-O3)
						- ğŸ”§ System calling conventions
						- ğŸ”— FFI to C libraries (linktime)
						- ğŸ“¦ Standalone executable

						---

						## ğŸ›ï¸ Register-Based VM Architecture

						âš¡ **RegVM: Lua-inspired register machine** âš¡

						| Stack VM | Register VM |
						|----------|-------------|
						| PUSH 5<br>PUSH 3<br>ADD<br>POP r0 | LoadK r0, 5<br>LoadK r1, 3<br>Add r2, r0, r1 |

						**Architecture Details:**

						- ğŸ“Ÿ 256 registers per function frame (8-bit addressing)
						- ğŸ’¾ 65536 constants per function (16-bit index)
						- ğŸ¯ 3-address instruction format (A = B op C)
						- ğŸ”§ Multiple instruction encodings: ABC, ABx, AsBx, Ax
						- âš¡ Fused instructions for common patterns

						---

						## ğŸ’¾ Bytecode Instructions

						**Instruction Categories:**

						| Category | Instructions |
						|----------|--------------|
						| ğŸ“¦ **Load/Store** | LoadK, Move, GetGlobal, SetGlobal |
						| ğŸ§® **Arithmetic** | Add, Sub, Mul, Div, Mod, Neg |
						| ğŸ”¢ **Comparison** | Eq, Lt, Le, Gt, Ge, Ne |
						| ğŸ¯ **Control Flow** | Jump, JumpIf, JumpIfNot, TestJump |
						| ğŸ“ **Function Calls** | Call, Return |
						| âš¡ **Fused Instructions** | AddAdd, MulAdd, LoadAddStore, EqStore |

						---

						## ğŸ’¾ Bytecode Caching

						**Performance improvement:** ğŸš€ faster subsequent runs

						**First run:**<br>
						`Source â†’ Parse â†’ Typecheck â†’ Prove â†’ Compile â†’ Cache`

						**Subsequent runs:**<br>
						`Source Hash Check â†’ Load Cached Bytecode â†’ Run`

						**Cache invalidation:**
						- âœ… Source file changed â†’ recompile
						- âœ… Source hash mismatch â†’ recompile
						- âœ… Bytecode version changed â†’ recompile
						- âœ… Compiler binary changed â†’ recompile
						- âœ… Compiler flags changed â†’ recompile
					</textarea>
				</section>

				<!-- Slide: Implementation Language: Nim -->
				<section class="center compact" data-markdown>
					<textarea data-template>
						## ğŸ‘‘ Etch compiler is written in Nim ğŸ¯

						**Why Nim for compiler development:**
						- âœ¨ Compiles to C â†’ Portable, fast execution
						- âœ¨ Python-like syntax â†’ Readable codebase
						- âœ¨ Zero-cost abstractions â†’ Efficient compilation
						- âœ¨ Memory safe with no GC â†’ No crashes and leaks
						- âœ¨ Strong standard library â†’ Less boilerplate
						- âœ¨ Metaprogramming â†’ DSL capabilities

						**Benefits for Etch:**
						- ğŸŒ³ Clean AST representation with algebraic types
						- ğŸ”„ Pattern matching for compiler passes
						- ğŸ”— Easy C FFI for library integration
						- â±ï¸ Fast compilation of the compiler itself (< 6 seconds)
					</textarea>
				</section>

				<!-- Slide: VSCode Debugger Integration -->
				<section class="center compact" data-markdown>
					<textarea data-template>
						## ğŸ› VSCode Debugger Integration

						**Full DAP (Debug Adapter Protocol) Support** âœ¨

						**Features:**
						- ğŸ”´ Set breakpoints in .etch files
						- â¯ï¸ Step through execution (step in/out/over)
						- ğŸ“Š View call stack
						- ğŸ” Inspect variables
						- ğŸ‘ï¸ Watch expressions (in progress)
						- ğŸ“Œ Conditional breakpoints (in progress)

						**Debug Server:**
						- ğŸ”Œ DAP protocol implementation (console based)
						- ğŸŒ TCP/IP communication (in progress)
						- ğŸ›ï¸ Integrated with RegVM
					</textarea>
				</section>

				<!-- Slide: Benchmark Results -->
				<section class="center compact" data-markdown>
					<textarea data-template>
						## ğŸ“Š Benchmark Results

						**Real benchmark data from `hyperfine` on an M3 (generated 2025-10-23)**

						---

						## ğŸ“Š Benchmark Results

						**Real benchmark data from `hyperfine` on an M3 (generated 2025-10-23)**

						| Benchmark | C | VM | Python 3 | C vs Py | VM vs Py |
						|-----------|---|-----|----------|---------|----------|
						| ğŸ§® Arithmetic ops | <span style="color:lightgreen">6.3ms</span> | <span style="color:green">74.2ms</span> | 131.5ms | **20.9x** | **1.8x** |
						| ğŸ“¦ Array ops | <span style="color:lightgreen">7.5ms</span> | <span style="color:green">34.2ms</span> | 54.1ms | **7.2x** | **1.6x** |
						| ğŸ” For loops | <span style="color:lightgreen">11.3ms</span> | <span style="color:green">21.4ms</span> | 52.4ms | **4.6x** | **2.4x** |
						| ğŸ“ Function calls | <span style="color:lightgreen">8.1ms</span> | <span style="color:green">39.8ms</span> | 46.4ms | **5.7x** | **1.2x** |
						| ğŸ”¢ Math intensive | <span style="color:lightgreen">5.5ms</span> | <span style="color:green">33.0ms</span> | 39.7ms | **7.2x** | **1.2x** |
						| ğŸ’¾ Memory alloc | <span style="color:lightgreen">1.7ms</span> | <span style="color:green">12.0ms</span> | 30.1ms | **17.7x** | **2.5x** |
						| ğŸ”„ Nested loops | <span style="color:lightgreen">5.6ms</span> | <span style="color:orangered">70.8ms</span> | 52.0ms | **9.3x** | 0.73x |
						| ğŸ“ String ops | <span style="color:green">13.8ms</span> | <span style="color:lightgreen">9.8ms</span> | 32.3ms | **2.3x** | **3.3x** |

						**Key Takeaway:** C backend ~2-21x faster than Python, VM competitive for many workloads

						---

						## ğŸš€ More Optimization Opportunities

						**Current Optimizations:**
						- âœ… Constant folding (complete - integers, floats, bools, strings)
						- âœ… Dead code elimination
						- âœ… Range-based check elimination
						- âœ… Fused instructions
						- âœ… Bytecode caching
						- âœ… Pure function compile-time evaluation

						**Future Optimizations:**
						- ğŸ”„ Loop hoisting optimizations
						- ğŸ§® Common subexpression elimination
						- ğŸ¨ Type-specialized instructions
						- ğŸ“¦ Function inlining
						- ğŸ¯ Register coalescing

						**The compiler keeps getting faster!**
					</textarea>
				</section>

				<!-- Slide: Development Experience -->
				<section class="center compact" data-markdown>
					<textarea data-template>
						## ğŸ§ª Development Experience

						**Etch provides multiple tools for exploration:**

						**Experimentation:**
						- âš¡ Test comptime evaluation limits
						- ğŸ”¬ Understand prover range analysis
						- ğŸ“Š Profile VM vs C backend performance
						- ğŸ¨ Generate code through metaprogramming

						**Tooling:**
						- ğŸ¨ VSCode extension with syntax highlighting
						- ğŸ› DAP debugger integration
						- ğŸ“ Verbose logging for compiler internals
						- ğŸ“ˆ Performance benchmarking with `just perf`

						**Learning compiler technology:**
						- ğŸ” Inspect bytecode with verbose mode
						- ğŸ›¡ï¸ Study prover analysis output
						- ğŸ“„ Compare generated C code
						- ğŸš€ Understand optimization passes
					</textarea>
				</section>

				<!-- Slide: Who Is Etch For? -->
				<section class="center compact" data-markdown>
					<textarea data-template>
						## ğŸ¯ Who Is Etch For?

						**Perfect for:**

						- ğŸ”¬ Compiler enthusiasts exploring PL design

						- ğŸ›¡ï¸ Programmers trying safety without complexity

						- ğŸ® Game developers needing a fun scripting runtime

						- ğŸ“š Discovering program verification
					</textarea>
				</section>

				<!-- Slide 36: Current Status -->
				<section class="center compact" data-markdown>
					<textarea data-template>
						## ğŸ¯ Current Status

						### Language Status: Active Development ğŸš§

						**What works:**
						- âœ… Core language features
						- âœ… Safety prover with range analysis
						- âœ… Compile-time execution
						- âœ… Bytecode VM with caching
						- âœ… C code generation backend
						- âœ… VSCode debugger integration
						- âœ… Test framework
						- âœ… Performance benchmarking

						**Production ready?** Not yet! âš ï¸

						**Great for:** ğŸ§ª Experiments Â· ğŸ“š Learning Â· ğŸ”¬ Research
					</textarea>
				</section>

				<!-- Slide : Roadmap -->
				<section class="center compact" data-markdown>
					<textarea data-template>
						## ğŸ—ºï¸ Optimization Roadmap

						**Phase 1: Bytecode optimization** ğŸ’¾
						- ğŸ”§ Re-enable optimizer
						- âœ… Enhanced constant folding (COMPLETED!)
						- ğŸ›¡ï¸ Integrate prover data into compiler

						**Phase 2: Instruction improvements** ğŸ¯
						- ğŸ”– Jump target tables
						- ğŸ“ ARG instructions
						- ğŸ”„ Reversed operations

						---

						## ğŸ—ºï¸ Roadmap

						**Phase 3: Advanced optimizations** ğŸš€
						- ğŸ”¬ Peephole optimization
						- ğŸ§® Common subexpression elimination
						- ğŸ”„ Loop optimizations

						**Phase 4: Type-aware optimization** ğŸ¨
						- ğŸ¯ Static type specialization
						- ğŸ“¦ Function inlining

						Note: There's a detailed improvement plan in the repo
					</textarea>
				</section>

				<!-- Slide: Live Demo Setup -->
				<section class="center compact" data-markdown>
					<textarea data-template>
						## Let's see Etch in action! ğŸ¬

						**Demos:**
						1. ğŸ›¡ï¸ Safety proofs catching bugs
						2. âš¡ Comptime execution
						3. ğŸ› Debugger in VSCode
						4. ğŸ“Š Performance comparison
						5. ğŸ”§ C backend code generation
					</textarea>
				</section>

				<!-- Slide: Questions? -->
				<section class="center compact" data-markdown>
					<textarea data-template>
						# Questions?

						---

						## **"Define once, Etch forever."**

						<img src="assets/matches.jpg" alt="Etch Matches" style="max-width: 40%; border-radius: 10px; margin: 20px auto;">

						### Thank you! ğŸš€
					</textarea>
				</section>

			</div>
		</div>

		<script src="dist/reveal.js"></script>
		<script src="plugin/notes/notes.js"></script>
		<script src="plugin/markdown/markdown.js"></script>
		<script src="plugin/highlight/highlight.js"></script>
		<script src="plugin/highlight/etch.js"></script>
		<script>
			// More info about initialization & config:
			// - https://revealjs.com/initialization/
			// - https://revealjs.com/config/
			Reveal.initialize({
				hash: true,
				slideNumber: true,
				showNotes: false,
				center: false,
				transition: 'slide',

				highlight: {
					beforeHighlight: (hljs) => {
						hljs.registerLanguage('etch', etchLang);
						hljs.registerLanguage('etchlang', etchLang);
					}
				},

				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [ RevealMarkdown, RevealHighlight, RevealNotes ]
			});
		</script>
	</body>
</html>