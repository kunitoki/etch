# regcompiler.nim
# Register-based bytecode compiler with aggressive optimizations

import std/[tables, options, hashes, strutils, strformat, algorithm]
import ../common/[constants, types, logging, errors, builtins]
import ../core/[vm, vm_types]
import ./[lifetime, optimizer]
import ./frontend/ast


type
  Compiler* = object
    prog*: BytecodeProgram                 # Generated bytecode program
    allocator*: RegisterAllocator          # Register allocator
    constMap*: Table[string, uint16]       # Constant string to index map
    loopStack*: seq[LoopInfo]              # Stack of loop info for break/continue
    optimizeLevel*: int                    # 0=debug (no opts), 1=release (all opts)
    verbose*: bool                         # Enable debug output
    debug*: bool                           # Include debug info in bytecode
    funInstances*: Table[string, FunctionDeclaration]  # Function declarations for default params
    lifetimeTracker*: LifetimeTracker      # Track variable lifetimes for debugging and destructors
    currentFunction*: string               # Current function being compiled (for debug info)
    globalVars*: seq[string]               # Names of global variables
    hasDefers*: bool                       # True if current function has defer statements
    deferCount*: int                       # Number of defers registered so far (for scope tracking)
    refVars*: Table[uint8, EtchType]       # Track ref-typed variables: register -> type
    types*: Table[string, EtchType]        # User-defined types for accessing field defaults

  LoopInfo = object
    startLabel*: int          # Position of loop start
    continueLabel*: int       # Position of continue jump
    breakJumps*: seq[int]     # Positions of break jumps to patch
    loopVar*: uint8           # Register holding loop variable


# Forward declarations
proc compileExpression(c: var Compiler, e: Expression, preferredDest: uint8 = InvalidRegister): uint8
proc compileStatement(c: var Compiler, s: Statement)


# Helper to add constants
proc addConst(c: var Compiler, val: V): uint16 =
  # Check if constant already exists (constant folding)
  for i, existing in c.prog.constants:
    if existing.kind == val.kind:
      case val.kind:
      of vkString:
        if existing.sval == val.sval:
          return uint16(i)
      of vkFloat:
        if existing.fval == val.fval:
          return uint16(i)
      of vkInt:
        if existing.ival == val.ival:
          return uint16(i)
      of vkBool:
        if existing.bval == val.bval:
          return uint16(i)
      of vkChar:
        if existing.cval == val.cval:
          return uint16(i)
      of vkNil:
        return uint16(i)  # All nils are equal
      else:
        discard

  c.prog.constants.add(val)
  let idx = uint16(c.prog.constants.len - 1)
  return idx


proc addStringConst(c: var Compiler, s: string): uint16 =
  if c.constMap.hasKey(s):
    logCompiler(c.verbose, &"String '{s}' already in const pool at index {c.constMap[s]}")
    return c.constMap[s]

  let v = makeString(s)
  result = c.addConst(v)
  c.constMap[s] = result
  logCompiler(c.verbose, &"Added string '{s}' to const pool at index {result}")


proc makeEnumConstValue(enumType: EtchType, member: EnumMember): V =
  let useCustomString =
    member.stringValue.isSome and member.stringValue.get() != member.name
  let stringValue =
    if useCustomString:
      member.stringValue.get()
    else:
      enumType.name & "." & member.name
  makeEnum(enumType.enumTypeId, member.intValue, stringValue)


proc loadEnumConstant(c: var Compiler, enumType: EtchType, member: EnumMember, debug: DebugInfo): uint8 =
  let reg = c.allocator.allocReg()
  let constIdx = c.addConst(makeEnumConstValue(enumType, member))
  c.prog.emitABx(opLoadK, reg, constIdx, debug)
  reg


proc addFunctionIndex(c: var Compiler, funcName: string): uint16 =
  ## Add function name to function table and return its index
  ## The function table maps indices to function names for fast direct calls
  for i, name in c.prog.functionTable:
    if name == funcName:
      return uint16(i)

  let idx = uint16(c.prog.functionTable.len)
  c.prog.functionTable.add(funcName)
  logCompiler(c.verbose, &"Added function '{funcName}' to function table at index {idx}")
  return idx


proc makeDebugInfo(c: Compiler, pos: Pos): DebugInfo =
  ## Create debug info from AST position (only if debug mode enabled)
  if c.debug:
    result = DebugInfo(
      line: pos.line,
      col: pos.col,
      sourceFile: pos.filename,
      functionName: c.currentFunction
    )
  else:
    result = DebugInfo()  # Empty debug info in release mode


proc tryGetBuiltinIndex(name: string, idx: var uint16): bool =
  ## Safely resolve builtin name to BuiltinFuncId ordinal
  try:
    idx = uint16(getBuiltinId(name))
    return true
  except ValueError:
    return false


proc resolveCallTarget(c: var Compiler, funcName: string): tuple[opcode: OpCode, encodedIdx: uint16] =
  ## Decide which opcode/index combination should be emitted for a call
  if c.prog.functions.hasKey(funcName):
    let info = c.prog.functions[funcName]
    case info.kind
    of fkNative:
      result = (opCall, c.addFunctionIndex(funcName))
    of fkHost:
      result = (opCallHost, c.addFunctionIndex(funcName))
    of fkCFFI:
      result = (opCallFFI, c.addFunctionIndex(funcName))
    of fkBuiltin:
      # Still add to function table for debugging consistency
      discard c.addFunctionIndex(funcName)
      result = (opCallBuiltin, info.builtinId)
    return

  # Fallback: treat as native
  result = (opCall, c.addFunctionIndex(funcName))


proc emitCallInstruction(c: var Compiler, dest: uint8, funcName: string,
                         argCount: int, numResults: int,
                         debug: DebugInfo) =
  ## Emit a call instruction with the appropriate opcode based on callee kind
  let callTarget = c.resolveCallTarget(funcName)
  if callTarget.opcode == opCallBuiltin:
    assert callTarget.encodedIdx <= uint16(ord(BuiltinFuncId.high)), "Encoded builtin id is out of range"
  else:
    assert callTarget.encodedIdx < c.prog.functionTable.len.uint16, "Function table index out of range for emitted call"

  if argCount < 0 or argCount > 255:
    raise newException(ValueError, &"Call to {funcName} has unsupported arg count {argCount}")
  if numResults < 0 or numResults > 255:
    raise newException(ValueError, &"Call to {funcName} has unsupported result count {numResults}")

  c.prog.emitCall(callTarget.opcode, dest, callTarget.encodedIdx, uint8(argCount), uint8(numResults), debug)
  logCompiler(c.verbose, &"Emitted {callTarget.opcode} for {funcName} at reg {dest} with {argCount} args")


proc isTrackedVar(c: Compiler; expr: Expression; reg: uint8): bool =
  ## Check if register corresponds to an existing named variable (should not be freed)
  if expr.kind == ekVar and c.allocator.regMap.hasKey(expr.vname):
    return c.allocator.regMap[expr.vname] == reg
  return false


proc needsArrayCleanup(typ: EtchType): bool =
  ## Recursively check if an array type contains refs/weaks that need cleanup
  if typ == nil:
    return false
  case typ.kind:
  of tkRef, tkWeak:
    return true
  of tkArray:
    return needsArrayCleanup(typ.inner)
  else:
    return false


proc emitDecRefsForScope(c: var Compiler, excludeReg: int = -1, removeFromTracking: bool = false) =
  ## Emit opDecRef for all ref-typed variables in current scope
  ## This should be called before function returns or scope exits
  ## excludeReg: if >= 0, don't emit decRef for this register (for return values)
  ## removeFromTracking: if true, remove emitted registers from refVars to prevent double-decRef
  ## Emits in REVERSE register order to ensure proper destruction order
  logCompiler(c.verbose, &"emitDecRefsForScope: refVars count = {c.refVars.len}, excludeReg = {excludeReg}, removeFromTracking = {removeFromTracking}")

  # Collect all registers that need decRef
  var regsToDecRef: seq[uint8] = @[]
  for reg, typ in c.refVars:
    if excludeReg < 0 or reg != uint8(excludeReg):
      regsToDecRef.add(reg)

  # Sort in REVERSE order (highest register first) to ensure reverse allocation order
  regsToDecRef.sort(system.cmp[uint8], order = Descending)

  # Emit cleanup code in reverse register order
  for reg in regsToDecRef:
    let typ = c.refVars[reg]

    # Check if this is an array of refs or weaks (or nested arrays containing them)
    if typ.kind == tkArray and typ.inner != nil and (typ.inner.kind == tkRef or typ.inner.kind == tkWeak or (typ.inner.kind == tkArray and needsArrayCleanup(typ.inner))):
      # For arrays of refs, we need to DecRef each element
      logCompiler(c.verbose, &"Emitting DecRef cleanup for array[ref] in reg {reg}")

      # Get array length into a temp register
      let lenReg = c.allocator.allocReg()
      c.prog.emitABC(opLen, lenReg, reg, 0)

      # Allocate registers for loop: index and element
      let idxReg = c.allocator.allocReg()
      let elemReg = c.allocator.allocReg()

      # Initialize index to length (we'll iterate backwards)
      c.prog.emitABC(opMove, idxReg, lenReg, 0)

      # Loop start position
      let loopStart = c.prog.instructions.len

      # Decrement index by 1 first (so we go from length-1 down to 0)
      # opSubI uses bx format: lower 8 bits = source reg, upper 8 bits = immediate
      c.prog.emitABx(opSubI, idxReg, uint16(idxReg) or (uint16(1) shl 8))

      # Check if index >= 0 by testing 0 <= index
      let zeroConst = c.addConst(makeInt(0))
      let zeroReg = c.allocator.allocReg()
      c.prog.emitABx(opLoadK, zeroReg, zeroConst)
      c.prog.emitABC(opLe, 0, zeroReg, idxReg)  # Skip next instruction if 0 <= index (i.e., if index >= 0)

      # Jump to end if index < 0 (we skip this jump when index >= 0)
      let jmpEndPos = c.prog.instructions.len
      c.prog.emitAsBx(opJmp, 0, 0)

      c.allocator.freeReg(zeroReg)

      # Get array element
      c.prog.emitABC(opGetIndex, elemReg, reg, idxReg)

      # DecRef element
      c.prog.emitABC(opDecRef, elemReg, 0, 0)

      # Jump back to loop start
      let jmpBackOffset = loopStart - c.prog.instructions.len - 1
      c.prog.emitAsBx(opJmp, 0, int16(jmpBackOffset))

      # Patch jump to end
      c.prog.instructions[jmpEndPos].sbx = int16(c.prog.instructions.len - jmpEndPos - 1)

      # Free temporary registers
      c.allocator.freeReg(elemReg)
      c.allocator.freeReg(idxReg)
      c.allocator.freeReg(lenReg)

      logCompiler(c.verbose, &"Emitted array[ref] cleanup loop for reg {reg}")
    else:
      # Simple ref or weak - just emit DecRef
      c.prog.emitABC(opDecRef, reg, 0, 0)
      logCompiler(c.verbose, &"Emitted opDecRef for ref variable in reg {reg} at scope exit")

  # Remove from tracking if requested (for nested scopes)
  if removeFromTracking:
    for reg in regsToDecRef:
      c.refVars.del(reg)
      logCompiler(c.verbose, &"Removed reg {reg} from refVars tracking")


# Add includes for expression compilation
include compile_expression/type_expression
include compile_expression/cast_expression
include compile_expression/ops_expression
include compile_expression/call_expression
include compile_expression/array_expression
include compile_expression/ref_expression
include compile_expression/monad_expression
include compile_expression/match_expression
include compile_expression/object_expression
include compile_expression/if_expression
include compile_expression/comp_expression
include compile_expression/coroutine_expression

proc compileLambdaExpression(c: var Compiler, e: Expression, preferredDest: uint8 = InvalidRegister): uint8

proc compileExpression(c: var Compiler, e: Expression, preferredDest: uint8 = InvalidRegister): uint8 =
  ## Compile expression to register, return register number

  result = case e.kind:
  of ekNil: compileNilExpression(c, e)
  of ekBool: compileBoolExpression(c, e)
  of ekChar: compileCharExpression(c, e)
  of ekInt: compileIntExpression(c, e)
  of ekFloat: compileFloatExpression(c, e)
  of ekString: compileStringExpression(c, e)
  of ekVar: compileVarExpression(c, e)
  of ekCast: compileCastExpression(c, e)
  of ekBin: compileBinExpression(c, e)
  of ekUn: compileUnExpression(c, e)
  of ekCall: compileCallExpression(c, e)
  of ekArray: compileArrayExpression(c, e)
  of ekTuple: compileTupleExpression(c, e)
  of ekIndex: compileIndexExpression(c, e)
  of ekSlice: compileSliceExpression(c, e)
  of ekArrayLen: compileArrayLenExpression(c, e)
  of ekNewRef: compileNewRefExpression(c, e)
  of ekDeref: compileDerefExpression(c, e)
  of ekNew: compileNewExpression(c, e)
  of ekOptionSome: compileOptionSomeExpression(c, e)
  of ekOptionNone: compileOptionNoneExpression(c, e)
  of ekResultOk: compileResultOkExpression(c, e)
  of ekResultErr: compileResultErrorExpression(c, e)
  of ekResultPropagate: compileResultPropagateExpression(c, e)
  of ekMatch: compileMatchExpression(c, e)
  of ekObjectLiteral: compileObjectLiteralExpression(c, e)
  of ekFieldAccess: compileFieldAccessExpression(c, e)
  of ekIf: compileIfExpression(c, e)
  of ekComptime: compileComptimeExpression(c, e)
  of ekCompiles: compileCompilesExpression(c, e)
  of ekYield: compileYieldExpression(c, e)
  of ekResume: compileResumeExpression(c, e)
  of ekSpawn: compileSpawnExpression(c, e)
  of ekChannelNew: compileChannelNewExpression(c, e)
  of ekChannelSend: compileChannelSendExpression(c, e)
  of ekChannelRecv: compileChannelRecvExpression(c, e)
  of ekLambda: compileLambdaExpression(c, e, preferredDest)
  of ekTypeof: compileTypeofExpression(c, e)
  of ekSpawnBlock:
    # Spawn blocks are typically only used within spawn
    raise newCompileError(e.pos, "Spawn blocks can only be used with spawn")


# Add includes for statement compilation
include compile_statement/for_statement
include compile_statement/expr_statement
include compile_statement/var_statement
include compile_statement/unpack_statement
include compile_statement/assign_statement
include compile_statement/if_statement
include compile_statement/while_statement
include compile_statement/return_statement
include compile_statement/break_statement
include compile_statement/comp_statement
include compile_statement/defer_statement
include compile_statement/discard_statement
include compile_statement/type_statement
include compile_statement/import_statement
include compile_statement/block_statement
include compile_statement/field_statement

proc compileStatement(c: var Compiler, s: Statement) =
  case s.kind:
  of skExpression: compileExpressionStatement(c, s)
  of skVar: compileVarStatement(c, s)
  of skTupleUnpack: compileTupleUnpackStatement(c, s)
  of skObjectUnpack: compileObjectUnpackStatement(c, s)
  of skAssign: compileAssignStatement(c, s)
  of skCompoundAssign: compileCompoundAssignStatement(c, s)
  of skIf: compileIfStatement(c, s)
  of skFor: compileForLoopStatement(c, s)
  of skWhile: compileWhileStatement(c, s)
  of skReturn: compileReturnStatement(c, s)
  of skBreak: compileBreakStatement(c, s)
  of skComptime: compileComptimeStatement(c, s)
  of skDefer: compileDeferStatement(c, s)
  of skTypeDecl: compileTypeDeclStatement(c, s)
  of skImport: compileImportStatement(c, s)
  of skDiscard: compileDiscardStatement(c, s)
  of skBlock: compileBlockStatement(c, s)
  of skFieldAssign: compileFieldIndexAssignStatement(c, s)


proc compileFunctionDeclaration(c: var Compiler, name: string, params: seq[Param], retType: EtchType, body: seq[Statement]): int =
  ## Compile a function declaration and return the maximum register used

  c.currentFunction = name # Set current function for debug info
  c.hasDefers = false      # Reset defer tracking for this function
  c.deferCount = 0         # Reset defer count for this function

  # Reset allocator for new function - preserve max register count
  c.allocator = RegisterAllocator(
    nextReg: 0,
    maxRegs: uint8(MAX_REGISTERS),
    highWaterMark: 0,
    regMap: initTable[string, uint8]()
  )

  # Reset ref variable tracking for new function
  c.refVars = initTable[uint8, EtchType]()

  # Reset lifetime tracker for this function
  let startPC = c.prog.instructions.len
  c.lifetimeTracker = newLifetimeTracker()
  c.lifetimeTracker.enterScope(startPC)

  # Track parameters
  for param in params:
    let paramReg = c.allocator.allocReg(param.name)
    c.lifetimeTracker.declareVariable(param.name, paramReg, startPC)
    c.lifetimeTracker.defineVariable(param.name, startPC)

  # Compile function body
  for stmt in body:
    c.compileStatement(stmt)

  # Execute all registered defers at the end of the function (only if function has any)
  # Always emit an instruction to keep jump offsets consistent
  if c.hasDefers:
    c.prog.emitABC(opExecDefers, 0, 0, 0)

  # Emit decRefs for all ref variables AFTER defers (defers might use the refs)
  c.emitDecRefsForScope()
  c.prog.emitABC(opReturn, 0, 0, 0)

  # Exit function scope
  let endPC = c.prog.instructions.len
  c.lifetimeTracker.exitScope(endPC)

  # Build and optimize lifetime data
  c.lifetimeTracker.buildPCMap()
  if c.optimizeLevel >= 1:
    c.lifetimeTracker.optimizeLifetimes()

  # Save lifetime data (allocate on heap)
  let lifetimeData = c.lifetimeTracker.exportFunctionData(name)
  var heapData = new(FunctionLifetimeData)
  heapData[] = lifetimeData
  c.prog.lifetimeData[name] = cast[pointer](heapData)
  GC_ref(heapData)  # Keep a GC reference to prevent collection

  # Save variable-to-register mapping for debugging
  c.prog.varMaps[name] = c.allocator.regMap

  # Debug: dump lifetime info if verbose
  if c.verbose:
    c.lifetimeTracker.dumpLifetimes()

  # Apply optimization passes
  if c.optimizeLevel >= 1:
    # Extract function instructions
    let funcInstructions = c.prog.instructions[startPC ..< endPC]
    let funcDebug = c.prog.debugInfo[startPC ..< endPC]
    var funcEntries: seq[InstructionEntry] = @[]
    for idx in 0 ..< funcInstructions.len:
      funcEntries.add(InstructionEntry(instr: funcInstructions[idx], debug: funcDebug[idx]))

    # Build lifetime map: register -> LifetimeRange
    var lifetimes = initTable[uint8, LifetimeRange]()
    for lifetime in c.lifetimeTracker.ranges:
      lifetimes[lifetime.register] = lifetime

    # Run optimizer
    let config = newOptimizerConfig(c.optimizeLevel, c.verbose)
    let optimizedEntries = optimizeFunction(funcEntries, lifetimes, c.prog.constants, c.prog, config)

    # Check if optimization changed anything
    var changed = optimizedEntries.len != funcInstructions.len
    if not changed:
      for i in 0 ..< funcInstructions.len:
        if optimizedEntries[i].instr != funcInstructions[i]:
          changed = true
          break

    # Replace function instructions if optimization changed them
    if changed:
      # Build new instruction/debug sequences: before + optimized + after
      var newInstructions: seq[Instruction] = @[]
      var newDebug: seq[DebugInfo] = @[]
      # Add instructions before this function
      for i in 0 ..< startPC:
        newInstructions.add(c.prog.instructions[i])
        newDebug.add(c.prog.debugInfo[i])
      # Add optimized instructions
      for entry in optimizedEntries:
        newInstructions.add(entry.instr)
        newDebug.add(entry.debug)
      # Add instructions after this function
      for i in endPC ..< c.prog.instructions.len:
        newInstructions.add(c.prog.instructions[i])
        newDebug.add(c.prog.debugInfo[i])
      # Replace entire instruction sequence
      c.prog.instructions = newInstructions
      c.prog.debugInfo = newDebug

      logCompiler(c.verbose, &"Optimizer: {funcInstructions.len} -> {optimizedEntries.len} instructions")

  # Add implicit return if needed
  if c.prog.instructions.len == 0 or
     c.prog.instructions[^1].op != opReturn:
    # Emit decRefs for all ref variables before implicit return
    c.emitDecRefsForScope()
    c.prog.emitABC(opReturn, 0, 0, 0)  # No results

  # Return the maximum register count used (highWaterMark tracks the highest nextReg value)
  result = int(c.allocator.highWaterMark)


proc compileProgram*(p: ast.Program, optimizeLevel: int = 1, verbose: bool = false, debug: bool = true): BytecodeProgram =
  ## Compile AST to register-based bytecode with optimizations
  if verbose:
    logCompiler(verbose, &"Starting compilation, funInstances count: {p.funInstances.len}")
    for fname, _ in p.funInstances:
      logCompiler(verbose, &"   Function available: {fname}")

  var compiler = Compiler(
    prog: BytecodeProgram(
      instructions: @[],
      debugInfo: @[],
      constants: @[],
      functions: initTable[string, FunctionInfo](),
      functionTable: @[],
      lifetimeData: initTable[string, pointer](),
      varMaps: initTable[string, Table[string, uint8]]()
    ),
    allocator: RegisterAllocator(
      nextReg: 0,
      maxRegs: uint8(MAX_REGISTERS),
      highWaterMark: 0,
      regMap: initTable[string, uint8]()
    ),
    constMap: initTable[string, uint16](),
    loopStack: @[],
    globalVars: @[],
    optimizeLevel: optimizeLevel,
    verbose: verbose,
    debug: debug,
    funInstances: p.funInstances,
    lifetimeTracker: newLifetimeTracker(),
    refVars: initTable[uint8, EtchType](),
    types: p.types
  )

  # Collect global variable names FIRST - before compiling functions
  # This allows functions to know which variables are globals
  for globalStatement in p.globals:
    if globalStatement.kind == skVar:
      compiler.globalVars.add(globalStatement.vname)

  logCompiler(verbose, &"Collected {compiler.globalVars.len} global variables: {compiler.globalVars}")

  # Populate function info from AST - both CFFI and native functions
  for fname, funcDecl in p.funInstances:
    # Extract base name from mangled name
    var baseName = functionNameFromSignature(fname)

    # Extract parameter types and default values
    var paramTypes: seq[string] = @[]
    var defaultValues: seq[Option[Expression]] = @[]
    for param in funcDecl.params:
      if param.typ != nil:
        paramTypes.add($param.typ)
      else:
        paramTypes.add("")  # Unknown type
      defaultValues.add(param.defaultValue)

    if funcDecl.isCFFI:
      # Store CFFI function info in unified table
      compiler.prog.functions[fname] = FunctionInfo(
        name: fname,
        baseName: baseName,
        kind: fkCFFI,
        paramTypes: paramTypes,
        returnType: if funcDecl.ret != nil: $funcDecl.ret else: "",
        library: "",        # Will be filled by compiler.nim
        libraryPath: "",    # Will be filled by compiler.nim
        symbol: baseName    # Use base name as symbol for now
      )

      logCompiler(verbose, &"Identified C FFI function: {fname} -> {baseName}")
    elif funcDecl.isBuiltin:
      var builtinIdx: uint16 = 0
      if not tryGetBuiltinIndex(baseName, builtinIdx):
        logCompiler(true, &"Warning: builtin '{baseName}' not registered; defaulting to id 0")
      compiler.prog.functions[fname] = FunctionInfo(
        name: fname,
        baseName: baseName,
        kind: fkBuiltin,
        paramTypes: paramTypes,
        returnType: if funcDecl.ret != nil: $funcDecl.ret else: "",
        builtinId: builtinIdx
      )

      logCompiler(verbose, &"Identified builtin function: {fname} -> {baseName} (id {builtinIdx})")
    elif funcDecl.isHost:
      compiler.prog.functions[fname] = FunctionInfo(
        name: fname,
        baseName: baseName,
        kind: fkHost,
        paramTypes: paramTypes,
        returnType: if funcDecl.ret != nil: $funcDecl.ret else: ""
      )

      logCompiler(verbose, &"Identified host function: {fname} -> {baseName}")
    elif funcDecl.body.len == 0:
      var builtinIdx: uint16 = 0
      if tryGetBuiltinIndex(baseName, builtinIdx):
        compiler.prog.functions[fname] = FunctionInfo(
          name: fname,
          baseName: baseName,
          kind: fkBuiltin,
          paramTypes: paramTypes,
          returnType: if funcDecl.ret != nil: $funcDecl.ret else: "",
          builtinId: builtinIdx
        )
        logCompiler(verbose, &"Identified builtin function: {fname} -> {baseName} (id {builtinIdx})")
      else:
        compiler.prog.functions[fname] = FunctionInfo(
          name: fname,
          baseName: baseName,
          kind: fkHost,
          paramTypes: paramTypes,
          returnType: if funcDecl.ret != nil: $funcDecl.ret else: ""
        )
        logCompiler(verbose, &"Identified host function (fallback): {fname} -> {baseName}")
    else:
      # Store native function info placeholder (will be updated after compilation)
      compiler.prog.functions[fname] = FunctionInfo(
        name: fname,
        baseName: baseName,
        kind: fkNative,
        paramTypes: paramTypes,
        returnType: if funcDecl.ret != nil: $funcDecl.ret else: "",
        startPos: 0,        # Will be filled after compilation
        endPos: 0,          # Will be filled after compilation
        maxRegister: 0      # Will be filled after compilation
      )

      logCompiler(verbose, &"Identified native Etch function: {fname} -> {baseName}")

  # Compile all functions except main first
  for fname, funcDecl in p.funInstances:
    let isBuiltin = funcDecl.body.len == 0  # Builtin functions have no body
    let isCFFI = compiler.prog.functions.hasKey(fname) and compiler.prog.functions[fname].kind == fkCFFI

    logCompiler(verbose, &"Processing function: {fname} isBuiltin={isBuiltin} isCFFI={isCFFI} body.len={funcDecl.body.len}")

    if fname != MAIN_FUNCTION_NAME and not isBuiltin and not isCFFI:  # Skip builtin and C FFI functions
      let startPos = compiler.prog.instructions.len

      logCompiler(verbose, &"Compiling function {fname}")

      # Reset defer tracking for this function
      compiler.hasDefers = false

      # Reset allocator for new function
      compiler.allocator = RegisterAllocator(
        nextReg: 0,
        maxRegs: uint8(MAX_REGISTERS),
        highWaterMark: 0,
        regMap: initTable[string, uint8]()
      )

      # Reset ref variable tracking for new function
      compiler.refVars = initTable[uint8, EtchType]()

      # Reset lifetime tracker for new function
      compiler.lifetimeTracker = newLifetimeTracker()
      compiler.lifetimeTracker.enterScope(startPos)  # Enter function scope

      # Allocate registers for parameters and map them
      for i, param in funcDecl.params:
        let paramReg = compiler.allocator.allocReg(param.name)
        # Track parameter as declared and defined at function entry
        compiler.lifetimeTracker.declareVariable(param.name, paramReg, startPos)
        compiler.lifetimeTracker.defineVariable(param.name, startPos)
        logCompiler(verbose, &"Allocated parameter '{param.name}' to register {paramReg}")

      # Compile function body
      for stmt in funcDecl.body:
        compiler.compileStatement(stmt)

      # Execute all registered defers at the end of the function (only if function has any)
      # Always emit an instruction to keep jump offsets consistent
      if compiler.hasDefers:
        compiler.prog.emitABC(opExecDefers, 0, 0, 0)

      # Emit decRefs for all ref variables AFTER defers (defers might use the refs)
      compiler.emitDecRefsForScope()
      compiler.prog.emitABC(opReturn, 0, 0, 0)

      # Exit function scope
      let endPC = compiler.prog.instructions.len
      compiler.lifetimeTracker.exitScope(endPC)

      # Build PC map and optimize lifetimes
      compiler.lifetimeTracker.buildPCMap()
      if compiler.optimizeLevel >= 1:
        compiler.lifetimeTracker.optimizeLifetimes()

      # Save lifetime data for this function (allocate on heap)
      let lifetimeData = compiler.lifetimeTracker.exportFunctionData(fname)
      var heapData = new(FunctionLifetimeData)
      heapData[] = lifetimeData
      compiler.prog.lifetimeData[fname] = cast[pointer](heapData)
      GC_ref(heapData)  # Keep a GC reference to prevent collection

      # Debug: dump lifetime info if verbose
      if verbose:
        compiler.lifetimeTracker.dumpLifetimes()

      # Apply optimization passes
      if compiler.optimizeLevel >= 1:
        # Extract function instructions
        let funcInstructions = compiler.prog.instructions[startPos ..< endPC]
        let funcDebug = compiler.prog.debugInfo[startPos ..< endPC]
        var funcEntries: seq[InstructionEntry] = @[]
        for idx in 0 ..< funcInstructions.len:
          funcEntries.add(InstructionEntry(instr: funcInstructions[idx], debug: funcDebug[idx]))

        # Build lifetime map: register -> LifetimeRange
        var lifetimes = initTable[uint8, LifetimeRange]()
        for lifetime in compiler.lifetimeTracker.ranges:
          lifetimes[lifetime.register] = lifetime

        # Run optimizer
        let config = newOptimizerConfig(compiler.optimizeLevel, compiler.verbose)
        let optimizedEntries = optimizeFunction(funcEntries, lifetimes, compiler.prog.constants, compiler.prog, config)

        # Replace function instructions if optimization changed them
        if optimizedEntries.len != funcInstructions.len:
          # Build new instruction/debug sequences: before + optimized + after
          var newInstructions: seq[Instruction] = @[]
          var newDebug: seq[DebugInfo] = @[]
          # Add instructions before this function
          for i in 0 ..< startPos:
            newInstructions.add(compiler.prog.instructions[i])
            newDebug.add(compiler.prog.debugInfo[i])
          # Add optimized instructions
          for entry in optimizedEntries:
            newInstructions.add(entry.instr)
            newDebug.add(entry.debug)
          # Add instructions after this function
          for i in endPC ..< compiler.prog.instructions.len:
            newInstructions.add(compiler.prog.instructions[i])
            newDebug.add(compiler.prog.debugInfo[i])
          # Replace entire instruction sequence
          compiler.prog.instructions = newInstructions
          compiler.prog.debugInfo = newDebug

          logCompiler(verbose, &"Optimizer: {funcInstructions.len} -> {optimizedEntries.len} instructions")

      # Add implicit return if needed
      if compiler.prog.instructions.len == startPos or
         compiler.prog.instructions[^1].op != opReturn:
        # Emit decRefs for all ref variables before implicit return
        compiler.emitDecRefsForScope()
        compiler.prog.emitABC(opReturn, 0, 0, 0)

      let endPos = compiler.prog.instructions.len - 1

      # Extract base name from mangled name
      var baseName = functionNameFromSignature(fname)

      # Store function info with max register count
      let maxReg = int(compiler.allocator.highWaterMark)

      # Extract parameter types and return type from the function declaration
      var paramTypes: seq[string] = @[]
      var returnType: string = ""
      if p.funInstances.hasKey(fname):
        let funcDecl = p.funInstances[fname]
        for param in funcDecl.params:
          if param.typ != nil:
            paramTypes.add($param.typ)
          else:
            paramTypes.add("")  # Unknown type
        if funcDecl.ret != nil:
          returnType = $funcDecl.ret
        else:
          returnType = ""  # No explicit return type
      else:
        # Fallback to empty types
        paramTypes = @[]
        returnType = ""

      compiler.prog.functions[fname] = FunctionInfo(
        name: fname,
        baseName: baseName,
        kind: fkNative,
        paramTypes: paramTypes,
        returnType: returnType,
        startPos: startPos,
        endPos: endPos,
        maxRegister: maxReg
      )

      logCompiler(verbose, &"Compiled function {fname} at {startPos}..{endPos}")

  # Compile global initialization if needed
  if p.globals.len > 0:
    logCompiler(verbose, &"Compiling {p.globals.len} global variables")

    # Save position for global init
    let globalInitStart = compiler.prog.instructions.len

    # Reset allocator for global init scope
    compiler.allocator = RegisterAllocator(
      nextReg: 0,
      maxRegs: uint8(MAX_REGISTERS),
      regMap: initTable[string, uint8]()
    )

    # Compile global variable initialization and type declarations
    for globalStatement in p.globals:
      if globalStatement.kind == skVar:
        if globalStatement.vinit.isSome():
          # Compile the initialization expression
          let valueReg = compiler.compileExpression(globalStatement.vinit.get())
          # Store in global table using opInitGlobal (only sets if not already present)
          # This allows C API to override compile-time initialization
          let nameIdx = compiler.addStringConst(globalStatement.vname)
          # Use the statement's position for debug info so stepping works correctly
          compiler.prog.emitABx(opInitGlobal, valueReg, nameIdx, compiler.makeDebugInfo(globalStatement.pos))
          compiler.allocator.freeReg(valueReg)
      elif globalStatement.kind == skTypeDecl:
        # Process type declarations (especially enum types)
        logCompiler(verbose, "Processing global type declaration: " & globalStatement.typeName)
        compiler.compileStatement(globalStatement)

    # After global initialization, call main using opCall
    let mainNameReg = compiler.allocator.allocReg()
    # Call main function using opCall (native)
    compiler.emitCallInstruction(mainNameReg, MAIN_FUNCTION_NAME, 0, 0, DebugInfo())
    compiler.prog.emitABC(opReturn, 0, 0, 0)  # Return after main completes

    # Set entry point to global initialization
    compiler.prog.entryPoint = globalInitStart
    logCompiler(verbose, &"Entry point set to PC {globalInitStart} ({GLOBAL_INIT_FUNCTION_NAME} function)")

    # Register the global initialization code as a special function for debugging
    let globalInitEnd = compiler.prog.instructions.len - 1
    let globalMaxReg = int(compiler.allocator.highWaterMark)
    compiler.prog.functions[GLOBAL_INIT_FUNCTION_NAME] = FunctionInfo(
      name: GLOBAL_INIT_FUNCTION_NAME,
      baseName: GLOBAL_INIT_FUNCTION_NAME,  # Use the name as base name for now
      paramTypes: @[],  # Global init takes no parameters
      returnType: "",   # No return type
      kind: fkNative,
      startPos: globalInitStart,
      endPos: globalInitEnd,
      maxRegister: globalMaxReg
    )

    logCompiler(verbose, &"Registered {GLOBAL_INIT_FUNCTION_NAME} initialization function at PC {globalInitStart}..{globalInitEnd}")
  else:
    # Set entry point to main (will be compiled next)
    compiler.prog.entryPoint = compiler.prog.instructions.len
    logCompiler(verbose, &"Entry point set to PC {compiler.prog.entryPoint} (main function)")

  # Find and compile main function last
  if p.funInstances.hasKey(MAIN_FUNCTION_NAME):
    let mainFunc = p.funInstances[MAIN_FUNCTION_NAME]

    # Reset allocator for main
    compiler.allocator = RegisterAllocator(
      nextReg: 0,
      maxRegs: uint8(MAX_REGISTERS),
      regMap: initTable[string, uint8]()
    )

    let mainStartPos = compiler.prog.instructions.len
    let mainMaxReg = compiler.compileFunctionDeclaration(MAIN_FUNCTION_NAME, mainFunc.params, mainFunc.ret, mainFunc.body)
    let mainEndPos = compiler.prog.instructions.len

    # Store main function info
    var mainParamTypes: seq[string] = @[]
    var mainReturnType: string = ""
    if p.funInstances.hasKey(MAIN_FUNCTION_NAME):
      let mainFunc = p.funInstances[MAIN_FUNCTION_NAME]
      if mainFunc.ret != nil:
        mainReturnType = $mainFunc.ret
      else:
        mainReturnType = ""  # No explicit return type
    else:
      mainReturnType = ""

    compiler.prog.functions[MAIN_FUNCTION_NAME] = FunctionInfo(
      name: MAIN_FUNCTION_NAME,
      baseName: MAIN_FUNCTION_NAME,  # Use the name as base name for now
      paramTypes: mainParamTypes,
      returnType: mainReturnType,
      kind: fkNative,
      startPos: mainStartPos,
      endPos: mainEndPos,
      maxRegister: mainMaxReg
    )

    logCompiler(verbose, &"Compiled main function at {mainStartPos}..{mainEndPos}")

  return compiler.prog


proc compileLambdaExpression(c: var Compiler, e: Expression, preferredDest: uint8 = InvalidRegister): uint8 =
  let debug = c.makeDebugInfo(e.pos)
  result =
    if preferredDest != InvalidRegister: preferredDest
    else: c.allocator.allocReg()

  let funcIdx = c.addFunctionIndex(e.lambdaFunctionName)
  let funcIdxConst = c.addConst(makeInt(int64(funcIdx)))

  let captureCount = e.lambdaCaptures.len
  let capturesReg = c.allocator.allocReg()
  c.prog.emitABx(opNewArray, capturesReg, uint16(captureCount), debug)

  for i, captureName in e.lambdaCaptures:
    var captureExpr = Expression(kind: ekVar, vname: captureName, pos: e.pos)
    if i < e.lambdaCaptureTypes.len:
      captureExpr.typ = e.lambdaCaptureTypes[i]
    let captureReg =
      if captureExpr.kind == ekVar and c.allocator.regMap.hasKey(captureName):
        c.allocator.regMap[captureName]
      else:
        c.compileExpression(captureExpr)

    let idxReg = c.allocator.allocReg()
    let idxConst = c.addConst(makeInt(int64(i)))
    c.prog.emitABx(opLoadK, idxReg, idxConst, debug)
    c.prog.emitABC(opSetIndex, capturesReg, idxReg, captureReg, debug)
    c.allocator.freeReg(idxReg)
    if not isTrackedVar(c, captureExpr, captureReg):
      c.allocator.freeReg(captureReg)

  # Queue arguments for __make_closure (funcIdx, capture array)
  c.prog.emitABx(opArgImm, 0, funcIdxConst, debug)
  c.prog.emitABC(opArg, capturesReg, 0, 0, debug)

  # Emit call to __make_closure
  let callName = "__make_closure"
  let callFuncIdx = c.addFunctionIndex(callName)
  c.prog.emitCall(opCall, result, callFuncIdx, 2, 1, debug)
  c.allocator.freeReg(capturesReg)
